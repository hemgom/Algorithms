# Problem
'intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]' 인 `간격 배열`이 주어지면 간격이 겹치지 않도록 하기위해 제거해야 하는 `최소 간격 배열의 갯수` 를 반환한다.
<br/><br/>

## Constraints
- 배열 `intervals` 의 길이 범위는 '1 <= intervals.length <= 10<sup>5</sup>' 이다.
- `intervals[i].length == 2`
- '-5 × 10<sup>4</sup> <= start<sub>i</sub> < end<sub>i</sub> <= 5 × 10<sup>4</sup>'
<br/><br/>

## Category
`Array`, `Dynamic Programming`, `Sorting`, `Greedy`
<br/><br/><br/>

# 분석
문제에 설명된 연산에 대한 조건이 있긴하나 결국 `s1` 과 `s2` 가 가지는 영소문자의 종류와 빈도가 동일해야 서로 같은 문자열이 될 수 있다는게 핵심인 것 같다.
<br/><br/><br/>

# 풀이
```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
    
        Arrays.sort(intervals, (a,b) -> Integer.compare(a[1], b[1]));

        int point = 0;
        int count = 1;

        for (int i = 1; i < intervals.length; i++) {

            if (intervals[point][1] <= intervals[i][0]) {
                count++;
                point = i;
            }

        }

        return intervals.length - count;

    }
}
```
<br/><br/>

## 참조 문서
- [leetcode - 435](https://leetcode.com/problems/non-overlapping-intervals/)